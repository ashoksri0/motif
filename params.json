{"name":"Motif","tagline":"Scala-like pattern matching for Java 8","body":"## Overview\r\n\r\nMotif is a library for doing Scala-like pattern matching in Java. It uses a fluent API for building matching patterns with corresponding match expressions.\r\n\r\nMotif comes with many built-in matching types:\r\n* java.util.Optional\r\n* java.util.List\r\n* Primitives\r\n* Case classes\r\n* Tuples\r\n* Hamcrest matchers\r\n\r\n## Examples\r\n\r\n### FizzBuzz\r\n\r\n```java\r\nIntStream.range(0, 101).forEach(\r\n    n -> System.out.println(\r\n        match(Tuple2.of(n % 3, n % 5))\r\n            .when(tuple2(eq(0), eq(0))).get(() -> \"FizzBuzz\")\r\n            .when(tuple2(eq(0), any())).get(y -> \"Fizz\")\r\n            .when(tuple2(any(), eq(0))).get(x -> \"Buzz\")\r\n            .orElse(String.valueOf(n))\r\n            .getMatch()\r\n    )\r\n);\r\n```\r\n\r\n### Optional\r\n\r\n```java\r\nOptional<Person> personOpt = getPerson();\r\nmatch(personOpt)\r\n    .when(some(any())).then(person -> doStuff(person))\r\n    .when(none()).then(() -> System.out.println(\"Person not found\"))\r\n    .doMatch();\r\n```\r\n\r\n### Factorial\r\n\r\n```java\r\npublic long factorial(long i) {\r\n  return match(i)\r\n      .when(eq(0)).get(() -> 1l)\r\n      .when(any()).get(x -> x * factorial(x - 1))\r\n      .getMatch();\r\n}\r\n```\r\n\r\n### Nested Matching\r\n\r\n```java\r\nOptional<Tuple2<String, String>> opt = Optional.of(Tuple2.of(\"first\", \"second\"));\r\nmatch(opt)\r\n    .when(some(tuple2(eq(\"third\"), any()))).then(b -> doStuff(b))\r\n    .when(some(tuple2(any(), eq(\"second\")))).then(a -> doStuff(a))\r\n    .when(none()).then(() -> System.out.println(\"Tuple not found\"))\r\n    .doMatch();\r\n```\r\n\r\n### List Cons Matching\r\n\r\n```java\r\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\", \"d\");\r\nmatch(list)\r\n    .when(nil()).then(() -> System.out.println(\"Empty List\"))\r\n    .when(headNil(eq(\"b\"))).then(() -> System.out.println(\"Singleton List of 'b'\"))\r\n    .when(headNil(any())).then(head -> System.out.println(\"Singleton List of \" + head))\r\n    .when(headTail(any(), any())).then(\r\n        (head, tail) -> System.out.println(\"head: \" + head + \" Remaining: \" + tail))\r\n    .doMatch();\r\n```\r\n\r\n## Download\r\n\r\nDownload the latest JAR via Maven:\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>com.leacox.motif</groupId>\r\n  <artifactId>motif</artifactId>\r\n  <version>0.1</version>\r\n</dependency>\r\n```\r\n\r\n## License\r\n\r\n    Copyright 2015 John Leacox\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n        http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.","google":"UA-63842936-1","note":"Don't delete this file! It's used internally to help with page regeneration."}